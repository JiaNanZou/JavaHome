# 							       AKA 盖了冒儿了

#### **Java**

#####  OOP

###### 一些概念：

面向对象编程是一种思维方式和编码架构。

问题复杂度取决于抽象的类型和质量。

​	汇编语言对底层机器进行抽象，命令式语言对汇编语言进行抽象

​    机器模型和实际问题需要中间模型映射

​	面向对象程序设计语言的组件可以容易理解的表示出实际问题中的元素

​	一个对象类似于一台小型计算机，可以有输入输出。

面向对象语言五大基本特征

​	1、万物皆对象。可以认为对象是特殊的变量（可以存储数据），还可以接收请求；看得见摸得着，看不见的逻辑组件都能表示一位一个对象。

​	2、一段程序由可以接收消息的对象组成。

​	3、每个对象都能含有其他对象。利用已有对象构建新的对象，隐藏程序复杂度。

​	4、每种对象都有一个类型。什么类型决定对象能接收什么样的消息。

​	5、特定类型对象都能接收同种消息。可以显示相同或不同状态。

一个对象有状态，行为，和唯一标识。

每个对象都该有Interface（对外暴露的方法用于接收请求）

对象是服务的提供者。什么类型对象提供什么类型服务。

隐藏内部实现。只提供调用者需要知道了解的部分，隐藏细节。对于对外暴露的接口，可以修改替换其内部实现，而不影响其使用。

重用实现。当我们需要创建一种新的类型时，有些功能可以利用已有类型的实现来完成，这种方式称为组合，我们可以在程序运行时动态的替换掉成员对象，称为聚合，都称为有一个的关系。

新创建对象可以通过继承来复用已有的代码（新创建的对象，需要相同类似的行为），在已有的代码上进行对自身的定制。

当衍生类和基类对外暴露的行为是一样的话，可以说衍生类似一个基类类型，当衍生类含有如基类相反效果或其他的行为，可以说衍生像一个基类（虽然在Java上使用了extends关键字）。

多态。使用基类引用代替子类引用。好处：当我使用一个对象对外交互时需要传递一个参数，当我们使用基类作为形式参数，在调用的时候传递衍生类的实际参数，可以在不改变对象代码的情况下改变对象的行为。

单根继承。

###### 	**隐藏属性**

​		当子类定义一个成员变量名字与父类相同，则父类的属性会被隐藏，与属性的访问权限类型无关。要访问父类属性需要对子类进行强转，或这使用super关键字。

###### 	父类构造器

​		当我们new一个对象的时候，父类的构造器会在子类中调用是为了帮助初始化从父类继承过来的私有属性，子类只是拥有这些私有属性，没有访问权限。

##### 关键字

​	sealed 修饰一个类表示该类不可继承 以前没有关键字的时候使用final来实现

​	permits 搭配 sealed 关键字 对外开放游戏额类允许继承

##### 集合框架

##### **Exception**

受检与未受检异常。受检异常在代码中必须捕获处理或抛出。未受捡异常应该在代码中避免而不是捕获。如数学运算、数组越界、空指针异常。

如果一个异常能处理那么应该捕获不能处理应该抛出给调用方。

由于我们使用一个变量时，该变量必须声明且初始化；由于在try中无法确定哪行代码抛出异常，所以在try代码块中声明的变量，无法在catch代码块中使用。

异常最重要的时异常本身的类名。

##### Enum

预先定义好一组预先定义好的实例。

使用

```java
// 形式参数叫color 是int类型 怪怪的
public void doSomeThingWithColor(int color);  

public void doSomeThingWithColor(Color color);
```



##### Java自带工具类

###### 	Collections

​		提供一些静态方法操作或返回集合。



#### Spring

##### 	IoC容器

​		DI：依赖注入指的是当我们使用构造器或者工厂方法获取一个对象实例的时候，通过构造器，工厂方法，属性设置定义对象实例属性依赖的过程。spring容器在创建Bean的时候注入了对象实例依赖的属性，这就是控制反转（之前我们要给实例对象注入属性，都是需要显示的调用构造器，或者set方法等进行属性依赖定义）。

​		容器的职责是实例化，配置（bean的依赖关系），装配Bean。容器从xml配置文件，注解，java编码的方式读取需要管理哪些bean的指令。

​		创建Web应用的时候，Spring ContextLoaderListener实现了Tomcat的ServletContextListener 进行容器的初始化工作。

​		BeanDefinetions对象包含了类的全限定名，bean运行在容器当中的状态行为描述(scope,lifecycle, callbacks等)，一些特殊对象创建的配置信息，如连接的池的连接数等。

​		Spring Bean在容器中的命名，可以是由id name 属性进行 对bean进行命名，id 唯一 不允许特殊字符，name 允许特殊字符 并且可以多个名字 使用 空格 逗号 或者 分号 分隔；并且每个Bean可以添加别名。容器会为未设置id name的bean添加默认名称；类名首字母小写 规则由java.beans.Introspector.decapitalize定义实现。

​		Spring 容器可以利用构造器，工厂方法，Bean工厂进行实例化，工厂方法与Bean工厂可以在运行期间返回不同的对象，此外AOP的jdk动态代理也能改变Bean实例化返回的类型。要获取Bean的实际类型可以使用BeanFactory.getType方法。

​	 	Spring 依赖注入的主要两种方式 构造器注入 与 set方法注入。

​		 构造器依赖注入通过构造器进行属性参数的设置，静态工厂方法与之类似。当依赖未引用类型时我们可以通过ref属性进行属性的设置，当依赖未值类型时（数字，字符串），我们可以通过type属性指定属性的类型，也可以使用index 属性 匹配构造器参数位置进行设置，也可以直接使用name属性指定构造器参数的名字，但是这需要在debug flag 我们可以通过 @ConstructorProperties指定哪些属性达到使用name方式的使用。

​		setter注入方式可以在容器利用构造器或者静态方法返回的实例后进行属性注入，ApplicationContext还支持在通过Construct注入方式后再进行setter注入；可以使用编程的方式PropertyEditor 改变BeanDefninetion里面的属性这是编程式的；可以使用注解@Component  或 @Configguration + @Bean .

​		Spring官方推荐使用构造器注入，构造器注入可以让我们的Bean完全初始化好，可是参数过多的话，有点不好看。setter方式注入可以用于可选依赖的注入上，与 一些需要重复注入的依赖上 且 setter注入可以使用@Require注解进行标注为必须要传的，第三方提供的依赖不一定由setter方法但一定有构造器。

​		使用构造器注入理论上会有循环依赖问题，解决方式使用setter注入，Spring底层有对循环依赖进行处理。

​		xml标签形式注入依赖的方式property标签里面的name属性是bean的set方法。去掉set首字母小写。

#### CS
